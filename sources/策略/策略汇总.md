# Lean 4 常用策略（Tactics）完整指南

## 目录
1. [[#基础策略]]
2. [[#逻辑推理策略]]
3. [[#等式和改写策略]]
4. [[#归纳和递归策略]]
5. [[#简化和计算策略]]
6. [[#类型类和实例策略]]
7. [[#目标管理策略]]
8. [[#高级策略]]
---

## 基础策略

### 1. `intro`
**用法**: 引入假设或变量到上下文中。

**示例**:
```lean
example : ∀ x : ℕ, x + 0 = x := by
  intro x  -- 引入变量 x
  sorry
```

### 2. `intros`
**用法**: 一次引入多个假设或变量。

**示例**:
```lean
example : ∀ x y : ℕ, x + y = y + x := by
  intros x y  -- 同时引入 x 和 y
  sorry
```

### 3. `apply`
**用法**: 应用一个定理或函数来证明当前目标。

**示例**:
```lean
theorem add_comm (a b : ℕ) : a + b = b + a := sorry

example (x y : ℕ) : x + y = y + x := by
  apply add_comm  -- 应用交换律
```

### 4. `exact`
**用法**: 提供一个精确的证明项来完成目标。

**示例**:
```lean
example : 2 + 2 = 4 := by
  exact rfl  -- 使用反射性证明
```

### 5. `sorry`
**用法**: 暂时跳过证明，留待后续完成。

**示例**:
```lean
theorem hard_theorem : ∀ n : ℕ, n + 1 > n := by
  intro n
  sorry  -- 稍后完成
```

### 6. `assumption`
**用法**: 使用上下文中已有的假设来证明目标。

**示例**:
```lean
example (h : P) : P := by
  assumption  -- 直接使用假设 h
```

### 7. `have`
**用法**: 引入一个中间结论。

**示例**:
```lean
example (x : ℕ) : x + 1 + 1 = x + 2 := by
  have h : 1 + 1 = 2 := by norm_num
  rw [h]
```

### 8. `let`
**用法**: 引入一个局部定义。

**示例**:
```lean
example : ∃ x : ℕ, x > 5 := by
  let x := 10
  use x
  norm_num
```

---

## 逻辑推理策略

### 9. `constructor`
**用法**: 拆分合取、存在量词或结构体的证明目标。

**示例**:
```lean
example : P ∧ Q := by
  constructor  -- 拆分成两个目标：P 和 Q
  · sorry
  · sorry
```

### 10. `left` / `right`
**用法**: 证明析取（或）的左侧或右侧。

**示例**:
```lean
example : P ∨ Q := by
  left  -- 选择证明 P
  sorry
```

### 11. `cases`
**用法**: 对假设进行分情况讨论。

**示例**:
```lean
example (h : P ∨ Q) : Q ∨ P := by
  cases h with
  | inl hp => right; exact hp
  | inr hq => left; exact hq
```

### 12. `by_cases`
**用法**: 对一个命题进行排中律分析。

**示例**:
```lean
example (P : Prop) [Decidable P] : P ∨ ¬P := by
  by_cases h : P
  · left; exact h
  · right; exact h
```

### 13. `contradiction`
**用法**: 从矛盾的假设中得出结论。

**示例**:
```lean
example (h1 : P) (h2 : ¬P) : Q := by
  contradiction  -- P 和 ¬P 矛盾
```

### 14. `exfalso`
**用法**: 使用爆炸原理（从假命题推出任何命题）。

**示例**:
```lean
example (h : False) : P := by
  exfalso
  exact h
```

### 15. `absurd`
**用法**: 使用矛盾来证明目标。

**示例**:
```lean
example (h1 : P) (h2 : ¬P) : Q := by
  absurd h1 h2
```

### 16. `use`
**用法**: 提供存在量词的见证。

**示例**:
```lean
example : ∃ x : ℕ, x > 0 := by
  use 1
  norm_num
```

### 17. `obtain`
**用法**: 解构存在量词或合取。

**示例**:
```lean
example (h : ∃ x : ℕ, x > 0) : True := by
  obtain ⟨x, hx⟩ := h
  trivial
```

---

## 等式和改写策略

### 18. `rw`
**用法**: 使用等式改写目标或假设。

**示例**:
```lean
example (h : x = y) : x + 1 = y + 1 := by
  rw [h]  -- 将 x 替换为 y
```

### 19. `rwa`
**用法**: 改写后自动尝试用 `assumption` 完成。

**示例**:
```lean
example (h1 : x = y) (h2 : y + 1 = 5) : x + 1 = 5 := by
  rwa [h1]  -- 改写并使用 h2
```

### 20. `calc`
**用法**: 进行链式等式推理。

**示例**:
```lean
example (a b c : ℕ) (h1 : a = b) (h2 : b = c) : a = c := by
  calc
    a = b := h1
    _ = c := h2
```

### 21. `conv`
**用法**: 在特定位置进行转换。

**示例**:
```lean
example (x : ℕ) : x + x = 2 * x := by
  conv_lhs =>
    rw [← one_mul x]
    rw [← add_mul]
```

### 22. `congr`
**用法**: 证明函数应用的同余性。

**示例**:
```lean
example (f : ℕ → ℕ) (h : x = y) : f x = f y := by
  congr 1
  exact h
```

### 23. `ac_rfl`
**用法**: 使用结合律和交换律证明等式。

**示例**:
```lean
example (a b c : ℕ) : a + b + c = c + b + a := by
  ac_rfl
```

### 24. `ring`
**用法**: 在环结构中证明等式。

**示例**:
```lean
example (x y : ℤ) : (x + y)^2 = x^2 + 2*x*y + y^2 := by
  ring
```

### 25. `field_simp`
**用法**: 简化域中的分式。

**示例**:
```lean
example (x y : ℚ) (hx : x ≠ 0) : x / x = 1 := by
  field_simp
```

---

## 归纳和递归策略

### 26. `induction`
**用法**: 对归纳类型进行归纳证明。

**示例**:
```lean
example (n : ℕ) : 0 + n = n := by
  induction n with
  | zero => rfl
  | succ n ih => simp [Nat.add_succ, ih]
```

### 27. `induction'`
**用法**: 归纳的变体，生成不同的归纳假设形式。

**示例**:
```lean
example (n : ℕ) : n ≤ n + 1 := by
  induction' n with n ih
  · exact Nat.zero_le _
  · exact Nat.succ_le_succ ih
```

### 28. `match`
**用法**: 模式匹配（在 tactic 模式中）。

**示例**:
```lean
def foo : ℕ → ℕ
  | 0 => 1
  | n + 1 => foo n + 1

example : foo 3 = 4 := by
  rfl
```

### 29. `split`
**用法**: 对 if-then-else 或 match 进行分支。

**示例**:
```lean
example (n : ℕ) : (if n = 0 then 1 else n) ≥ 1 := by
  split
  · norm_num
  · omega
```

---

## 简化和计算策略

### 30. `simp`
**用法**: 使用简化引理库自动简化表达式。

**示例**:
```lean
example (x : ℕ) : x + 0 = x := by
  simp  -- 自动应用 Nat.add_zero
```

### 31. `simp_all`
**用法**: 对所有假设和目标进行简化。

**示例**:
```lean
example (h : x + 0 = y) : x = y := by
  simp_all
```

### 32. `simpa`
**用法**: 简化后应用 `assumption`。

**示例**:
```lean
example (h : x + 0 = y) : x = y := by
  simpa using h
```

### 33. `norm_num`
**用法**: 数值计算和规范化。

**示例**:
```lean
example : 2 + 2 = 4 := by
  norm_num
```

### 34. `norm_cast`
**用法**: 规范化类型转换。

**示例**:
```lean
example (n : ℕ) : (n : ℤ) + (1 : ℤ) = ((n + 1) : ℤ) := by
  norm_cast
```

### 35. `push_neg`
**用法**: 将否定推入量词内部。

**示例**:
```lean
example : ¬(∀ x, P x) ↔ ∃ x, ¬P x := by
  push_neg
```

### 36. `tauto`
**用法**: 自动证明重言式。

**示例**:
```lean
example : P ∨ ¬P → Q ∨ ¬Q := by
  tauto
```

### 37. `decide`
**用法**: 使用可判定性自动证明。

**示例**:
```lean
example : 5 < 10 := by
  decide
```

### 38. `trivial`
**用法**: 证明平凡的命题（如 `True`）。

**示例**:
```lean
example : True := by
  trivial
```

---

## 类型类和实例策略

### 39. `inferInstance`
**用法**: 自动推断类型类实例。

**示例**:
```lean
example : Add ℕ := by
  inferInstance
```

### 40. `refine`
**用法**: 提供部分证明项，留下待填充的洞。

**示例**:
```lean
example : ∃ x : ℕ, x > 0 := by
  refine ⟨1, ?_⟩
  norm_num
```

### 41. `refine'`
**用法**: `refine` 的变体，更灵活的洞填充。

**示例**:
```lean
example (h : P → Q) : P → Q := by
  refine' fun hp => ?_
  exact h hp
```

### 42. `convert`
**用法**: 将目标转换为相似形式并生成等式目标。

**示例**:
```lean
example (h : x + 1 = y) : x + 2 = y + 1 := by
  convert h using 1
  norm_num
```

---

## 目标管理策略

### 43. `show`
**用法**: 显式指定当前目标的形式。

**示例**:
```lean
example (x y : ℕ) : x + y = y + x := by
  show y + x = x + y
  sorry
```

### 44. `suffices`
**用法**: 证明一个充分条件。

**示例**:
```lean
example : P := by
  suffices h : Q by
    sorry  -- 从 Q 推出 P
  sorry  -- 证明 Q
```

### 45. `change`
**用法**: 改变目标的表示形式（定义上相等）。

**示例**:
```lean
example : 2 + 2 = 4 := by
  change 4 = 4
  rfl
```

### 46. `generalize`
**用法**: 泛化目标中的表达式。

**示例**:
```lean
example (x : ℕ) : x + x = 2 * x := by
  generalize h : x + x = y
  sorry
```

### 47. `specialize`
**用法**: 将全称命题特化到具体实例。

**示例**:
```lean
example (h : ∀ x : ℕ, x + 0 = x) : 5 + 0 = 5 := by
  specialize h 5
  exact h
```

### 48. `clear`
**用法**: 清除不需要的假设。

**示例**:
```lean
example (h1 : P) (h2 : Q) : P := by
  clear h2  -- 清除 h2
  exact h1
```

### 49. `rename`
**用法**: 重命名假设。

**示例**:
```lean
example (h : P) : P := by
  rename h => hp
  exact hp
```

### 50. `revert`
**用法**: 将上下文中的变量移回目标（`intro` 的逆操作）。

**示例**:
```lean
example (x : ℕ) (h : x > 0) : x > 0 := by
  revert x
  intro y
  exact h
```

---

## 高级策略

### 51. `ext`
**用法**: 使用扩展性证明（函数、集合等相等）。

**示例**:
```lean
example (f g : ℕ → ℕ) (h : ∀ x, f x = g x) : f = g := by
  ext x
  exact h x
```

### 52. `funext`
**用法**: 函数扩展性（`ext` 的特化版本）。

**示例**:
```lean
example (f g : ℕ → ℕ) : (∀ x, f x = g x) → f = g := by
  intro h
  funext x
  exact h x
```

### 53. `existsi`
**用法**: 提供存在量词的见证（旧版语法，现代用 `use`）。

**示例**:
```lean
-- 已被 use 替代
```

### 54. `subst`
**用法**: 使用等式替换变量。

**示例**:
```lean
example (x y : ℕ) (h : x = y) : x + 1 = y + 1 := by
  subst h
  rfl
```

### 55. `injection`
**用法**: 从构造子的相等性推出参数相等。

**示例**:
```lean
example (h : (1, 2) = (x, y)) : x = 1 ∧ y = 2 := by
  injection h with h1 h2
  constructor <;> assumption
```

### 56. `rcases`
**用法**: 递归地解构假设。

**示例**:
```lean
example (h : ∃ x, ∃ y, x + y = 10) : True := by
  rcases h with ⟨x, y, rfl⟩
  trivial
```

### 57. `rintro`
**用法**: 递归地引入并解构。

**示例**:
```lean
example : (∃ x, P x) → Q := by
  rintro ⟨x, hx⟩
  sorry
```

### 59. `omega`
**用法**: 解决线性算术不等式。

**示例**:
```lean
example (x y : ℕ) (h1 : x < y) (h2 : y < 10) : x < 10 := by
  omega
```

### 60. `linarith`
**用法**: 线性算术求解器。

**示例**:
```lean
example (x y : ℝ) (h1 : x ≤ y) (h2 : y < x + 1) : 0 < 1 := by
  linarith
```

### 61. `nlinarith`
**用法**: 非线性算术求解器。

**示例**:
```lean
example (x : ℝ) (h : x^2 ≥ 0) : True := by
  nlinarith
```


### 62. `continuity`
**用法**: 证明函数的连续性。

**示例**:
```lean
example : Continuous (fun x : ℝ => x^2) := by
  continuity
```

### 63. `mono`
**用法**: 证明单调性。

**示例**:
```lean
example (f : ℕ → ℕ) (h : Monotone f) (x y : ℕ) (hxy : x ≤ y) : f x ≤ f y := by
  mono
```

### 64. `positivity`
**用法**: 证明表达式的正性。

**示例**:
```lean
example (x : ℝ) (hx : x > 0) : x^2 > 0 := by
  positivity
```

### 65. `gcongr`
**用法**: 泛化的同余性策略。

**示例**:
```lean
example (a b c d : ℕ) (h1 : a ≤ b) (h2 : c ≤ d) : a + c ≤ b + d := by
  gcongr
```

### 66. `aesop`
**用法**: 自动化搜索策略（高级）。

**示例**:
```lean
example (h : P ∧ Q) : Q ∧ P := by
  aesop
```

### 67. `squeeze_simp`
**用法**: 显示 `simp` 使用的引理。

**示例**:
```lean
example (x : ℕ) : x + 0 = x := by
  squeeze_simp
  -- 会显示使用的引理
```

### 68. `trace`
**用法**: 追踪策略执行过程。

**示例**:
```lean
example : 2 + 2 = 4 := by
  trace "开始证明"
  norm_num
```

### 69. `skip`
**用法**: 跳过当前目标（等同于 `sorry` 但更明确）。

**示例**:
```lean
example : P := by
  skip
```

---
